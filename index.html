<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>APG Aggregated Test Page</title>
  <style>
    body {
      font-family: system-ui;
      margin: 24px;
    }
    .slot {
      border: 1px dashed #999;
      padding: 12px;
      margin: 12px 0;
      min-height: 90px;
    }
  </style>
</head>

<body>
  <h1>APG Aggregated Test</h1>
  <p>This page intentionally triggers multiple ad delivery issues on one load.</p>

  <!-- SLOT 1: registered, wrong network + empty response -->
  <div class="slot" id="div-gpt-ad-wrong-network">
    Slot: wrong network + empty response
  </div>

  <!-- SLOT 2: registered, unexpected size -->
  <div class="slot" id="div-gpt-ad-unexpected-size">
    Slot: unexpected size
  </div>

  <!-- SLOT 3: NOT REGISTERED -->
  <div class="slot" id="div-gpt-ad-not-registered">
    ❌ NOT REGISTERED IN GPT
  </div>

  <!-- ================================================= -->
  <!-- GPT STUB (INTENTIONALLY BROKEN FOR TESTING)        -->
  <!-- ================================================= -->
  <script>
    (function () {
      function makeSlot(id, path, sizes) {
        return {
          getSlotElementId() { return id; },
          getAdUnitPath() { return path; },
          getSizes() {
            return sizes.map(sz => ({
              getWidth() { return sz[0]; },
              getHeight() { return sz[1]; }
            }));
          }
        };
      }

      const slots = [
        // ❌ wrong network + empty response
        makeSlot(
          'div-gpt-ad-wrong-network',
          '/99999999/test/wrong-network',
          [[300, 250]]
        ),

        // ⚠️ unexpected size (defined 728x90, rendered 300x250)
        makeSlot(
          'div-gpt-ad-unexpected-size',
          '/12345678/test/unexpected-size',
          [[728, 90]]
        )
      ];

      window.googletag = {
        apiReady: true,
        cmd: {
          push(fn) { fn(); }
        },
        pubads() {
          return {
            getSlots() {
              return slots;
            },
            addEventListener(event, cb) {
              if (event === 'slotRenderEnded') {
                setTimeout(() => {
                  // EMPTY RESPONSE
                  cb({
                    slot: slots[0],
                    isEmpty: true,
                    size: null
                  });

                  // UNEXPECTED SIZE
                  cb({
                    slot: slots[1],
                    isEmpty: false,
                    size: [300, 250]
                  });
                }, 1200);
              }
            }
          };
        }
      };
    })();
  </script>

  <!-- ================================================= -->
  <!-- APG TAG – Aggregated v1 (FINAL)                   -->
  <!-- ================================================= -->
  <!-- ⬇⬇⬇ PASTE THE *FINAL TAG* YOU ALREADY HAVE HERE ⬇⬇⬇ -->
<script>
(function () {
  const CONFIG = {
    clientId: 'client-001',
    allowedDomain: 'smajli12.github.io',
    expectedNetworkId: '12345678',
    apiEndpoint: 'https://script.google.com/macros/s/AKfycbx-PFUcYyEXUR7Thw8kqzAWpCX74XY-4c-Si9myS69jloI9Vir_5YaZLXGCUiUquxMn/exec',
    siteToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRJZCI6ImNsaWVudC0wMDEiLCJpYXQiOjE3NjcyMDc4NjAsImV4cCI6MTc5ODc0Mzg2MH0.75Fih1agPeA_QTK3u3qpydbLuMAfr4_TqeoApKB6tAY',
    version: 'start-1.1.4-final',

    scanScheduleMs: [3500, 10000, 20000],
    aggregationWindowMs: 4500,
    dedupeTtlMs: 24 * 60 * 60 * 1000,

    domSlotSelector:
      'div[id^="div-gpt-ad"],div[id^="gpt-"],div[id^="ad-"],div[id*="ad-slot"],div[id*="gpt-ad"],div[id*="slot"]',

    revenueModel: {
      currency: 'USD',
      assumedRpm: 1,
      assumedImpressionsPerHour: 500
    }
  };

  const host = location.hostname;
  if (!(host === CONFIG.allowedDomain || host.endsWith('.' + CONFIG.allowedDomain))) return;

  const pageLoadId =
    Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);

  const issueBuffer = [];
  const seenThisLoad = new Set();
  let flushTimer = null;
  let hasScheduledFlush = false;

  function severityFor(type) {
    if (['gpt_not_loaded','wrong_network','slot_not_registered'].includes(type)) return 'high';
    if (['empty_response','unexpected_size'].includes(type)) return 'medium';
    return 'low';
  }

  function estimateRevenueRisk() {
    const h = (CONFIG.revenueModel.assumedImpressionsPerHour / 1000) *
              CONFIG.revenueModel.assumedRpm;
    return {
      estimationCurrency: CONFIG.revenueModel.currency,
      assumedRpm: CONFIG.revenueModel.assumedRpm,
      assumedImpressionsPerHour: CONFIG.revenueModel.assumedImpressionsPerHour,
      estimatedHourlyRevenueRisk: Math.round(h * 100) / 100,
      estimatedDailyRevenueRisk: Math.round(h * 24 * 100) / 100,
      estimationMethod: 'conservative_time_based_risk',
      revenueAssumptionsNote: '500 imps/hour, $1 RPM, conservative baseline'
    };
  }

  function dedupeKey(issue) {
    return [
      'apg',
      CONFIG.clientId,
      location.href,
      issue.issueType,
      issue.slotId || ''
    ].join('|');
  }

  function passesCrossPageDedupe(issue) {
    try {
      const k = dedupeKey(issue);
      const prev = localStorage.getItem(k);
      if (prev && Date.now() - Number(prev) < CONFIG.dedupeTtlMs) return false;
      localStorage.setItem(k, String(Date.now()));
      return true;
    } catch {
      return true;
    }
  }

  function scheduleFlushOnce() {
    if (hasScheduledFlush) return;
    hasScheduledFlush = true;
    flushTimer = setTimeout(flushIssues, CONFIG.aggregationWindowMs);
  }

  function recordIssue(issue) {
    const memKey = issue.issueType + '|' + (issue.slotId || '');
    if (seenThisLoad.has(memKey)) return;
    seenThisLoad.add(memKey);

    if (!passesCrossPageDedupe(issue)) return;

    issueBuffer.push({
      issueType: issue.issueType,
      slotId: issue.slotId || '',
      adUnitPath: issue.adUnitPath || '',
      networkId: issue.networkId,
      renderedSize: issue.renderedSize,
      definedSizes: issue.definedSizes,
      scanAttempt: issue.scanAttempt,
      scanDelayMs: issue.scanDelayMs,
      severity: severityFor(issue.issueType)
    });

    scheduleFlushOnce();
  }

  function flushIssues() {
    hasScheduledFlush = false;
    flushTimer = null;

    if (!Array.isArray(issueBuffer) || issueBuffer.length === 0) return;

    const payload = Object.assign({
      clientId: CONFIG.clientId,
      host: location.hostname,
      pageUrl: location.href,
      timestamp: new Date().toISOString(),
      tagVersion: CONFIG.version,
      pageLoadId,
      issueType: 'multiple_issues',
      severity: issueBuffer.some(i => i.severity === 'high') ? 'high' : 'medium',
      issues: issueBuffer.slice()
    }, estimateRevenueRisk());

    issueBuffer.length = 0;

    fetch(CONFIG.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${CONFIG.siteToken}`,
        'X-APG-Tag-Version': CONFIG.version
      },
      body: JSON.stringify(payload),
      keepalive: true
    }).catch(() => {});
  }

  function scan(attempt) {
    if (!window.googletag || !googletag.apiReady) {
      if (attempt === CONFIG.scanScheduleMs.length - 1) {
        recordIssue({
          issueType: 'gpt_not_loaded',
          scanAttempt: attempt + 1,
          scanDelayMs: CONFIG.scanScheduleMs[attempt]
        });
      }
      return;
    }

    const domIds = Array.from(document.querySelectorAll(CONFIG.domSlotSelector))
      .map(el => el.id)
      .filter(Boolean);

    const slots = googletag.pubads().getSlots();
    const gptIds = slots.map(s => s.getSlotElementId());

    domIds.forEach(id => {
      if (!gptIds.includes(id)) {
        recordIssue({
          issueType: 'slot_not_registered',
          slotId: id,
          scanAttempt: attempt + 1,
          scanDelayMs: CONFIG.scanScheduleMs[attempt]
        });
      }
    });

    slots.forEach(s => {
      const path = s.getAdUnitPath && s.getAdUnitPath();
      if (!path) return;
      const nid = path.split('/')[1];
      if (CONFIG.expectedNetworkId && nid !== CONFIG.expectedNetworkId) {
        recordIssue({
          issueType: 'wrong_network',
          slotId: s.getSlotElementId(),
          adUnitPath: path,
          networkId: nid,
          scanAttempt: attempt + 1,
          scanDelayMs: CONFIG.scanScheduleMs[attempt]
        });
      }
    });
  }

  function attachGptListeners() {
    (window.googletag = window.googletag || { cmd: [] }).cmd.push(function () {
      const pubads = googletag.pubads();
      if (pubads.__apgBound) return;
      pubads.__apgBound = true;

      pubads.addEventListener('slotRenderEnded', function (e) {
        const slotId = e.slot?.getSlotElementId?.() || '';
        const adUnitPath = e.slot?.getAdUnitPath?.() || '';

        if (e.isEmpty) {
          recordIssue({ issueType: 'empty_response', slotId, adUnitPath });
        }

        if (e.size && e.slot?.getSizes) {
          const rendered = e.size[0] + 'x' + e.size[1];
          const defined = e.slot.getSizes().map(
            s => s.getWidth() + 'x' + s.getHeight()
          );
          if (!defined.includes(rendered)) {
            recordIssue({
              issueType: 'unexpected_size',
              slotId,
              adUnitPath,
              renderedSize: rendered,
              definedSizes: defined
            });
          }
        }
      });
    });
  }

  function init() {
    attachGptListeners();
    CONFIG.scanScheduleMs.forEach((ms, i) => {
      setTimeout(() => scan(i), ms);
    });
  }

  try { init(); } catch (_) {}
})();
</script>

  <!-- (exactly the script from the previous message) -->

</body>
</html>
